# -*- coding: utf-8 -*-
"""price optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15JYTWPdVGrCqJpgWLNQNGyPBgXzQKob6

## Обработка данных
"""

from google.colab import drive
drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/gdrive/My Drive/input data

import pickle

with open('shop_info.pkl', 'rb') as f:
    sales = pickle.load(f)

with open('product_rels.pkl', 'rb') as f:
    relations = pickle.load(f)

for i in sales:
  sales[i][0] = sales[i].pop("apple")
  sales[i][1] = sales[i].pop("banana")
  sales[i][2] = sales[i].pop("pear")
  sales[i][3] = sales[i].pop("orange")
  sales[i][4] = sales[i].pop("lemon")

sales_dict = [] #average sales of each product per each shop
for i in sales:
  for k in range(0,5):
    sales_dict.append(sales[i][k])

import itertools
from itertools import product

shops = range(0,59)
fruits = range(0,5)
combinations = list(itertools.product(shops, fruits))

sales_quantity = dict(zip(combinations, sales_dict))

import pandas as pd
prices = pd.read_csv('prices.csv')

prices = prices[:24]

prices = prices[['price_apple',	'price_banana',	'price_pear',	'price_orange',	'price_lemon']]

prices_dict = prices.to_dict(orient='index')
#nested_dict

prices_dict[0]

for i in prices_dict: # i - строки
  prices_dict[i][0] = prices_dict[i].pop("price_apple")
  prices_dict[i][1] = prices_dict[i].pop("price_banana")
  prices_dict[i][2] = prices_dict[i].pop("price_pear")
  prices_dict[i][3] = prices_dict[i].pop("price_orange")
  prices_dict[i][4] = prices_dict[i].pop("price_lemon")

prices_dict[0]

price_dictionary = []
for i in prices_dict:
  for k in range(0,5):
    price_dictionary.append(prices_dict[i][k])

weeks = range(0,24)
fruits = range(0,5)
combinations2 = list(itertools.product(weeks, fruits))

print(len(price_dictionary))
print(len(combinations2))

prices_season = dict(zip(combinations2, price_dictionary))

len(relations.keys())

n = range(0,5)
m = range(0,5)
comb = list(itertools.product(n, m))
len(comb)

relations = dict(zip(comb, relations.values()))

relations[0,1] #продукт, продукт

prices_season[0,1] #неделя, продукт

sales_quantity[0,1] #магазин, продукт

"""## Оптимизация"""

pip install pyomo

from pyomo.environ import *
from pyomo.opt import SolverFactory

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# import sys
# 
# if 'google.colab' in sys.modules:
#     !pip install idaes-pse --pre
#     !idaes get-extensions --to ./bin
#     os.environ['PATH'] += ':bin'

!chmod 755 ipopt

#создание модели
model = ConcreteModel('promo')

model.S = RangeSet(0, 58) #S for shops
model.W = RangeSet(0, 23) #W for weeks
model.P = RangeSet(0, 4)  #P for products

#вектор цен
model.x = Var(model.W, model.P,domain = NonNegativeReals) #price for each week for each product

#целевая функция
objective_rule = sum(model.x[w,p]*
                    (
                        sales_quantity[s,p]*
                           (-(model.x[w,p]/prices_season[w,p])**2 - 0.075*model.x[w,p]/prices_season[w,p] + 2.85) /1.775
                          + sum((prices_season[w,o]/model.x[w,o])**2 * relations[o,p] * sales_quantity[s,o] for o in model.P)
                       )
                        for s in model.S for w in model.W for p in model.P)
model.obj = Objective(rule=objective_rule,sense=maximize)


#ограничения
model.constraintloop = ConstraintList()
for w in model.W:
  for p in model.P:
    model.constraintloop.add(expr=model.x[w,p] <= prices_season[w,p]* 1.25)
    model.constraintloop.add(expr=model.x[w,p] >= prices_season[w,p]* 0.75)

# Инициализация солвера и решение задачи)
SolverFactory('ipopt').solve(model, tee=True).write()
optimal = value(model.obj)

res = []
d1 = []
d2 = []
for w in model.W:
  for p in model.P:
    res.append(value(model.x[w,p]))
    d1.append(w)
    d2.append(p)

optimal

results= dict(zip(combinations2, res))

"""## Графики (в процессе)"""

def get_revenue(x:list) -> list:
  S = RangeSet(0, 58)
  W = RangeSet(0, 23)
  P = RangeSet(0, 4)

  return sum(x[w,p]*(sales_quantity[s,p]*(-(x[w,p]/prices_season[w,p])**2 - 0.075*x[w,p]/prices_season[w,p] + 2.85) /1.775
          + sum((prices_season[w,o]/x[w,o])**2 * relations[o,p] * sales_quantity[s,o] for o in P)) for s in S for w in W for p in P)

max_prices = []
for i in range(24):
  for j in range(5):
    max_prices.append(prices_season[i,j]*1.25)

max = dict(zip(combinations2, max_prices))

min_prices = []
for i in range(24):
  for j in range(5):
    min_prices.append(prices_season[i,j]*0.75)

min = dict(zip(combinations2, min_prices))

import numpy as np

random_prices = []
for i in range(24):
  for j in range(5):
    start = 0.75* prices_season[i,j]
    end = 1.25* prices_season[i,j]
    random_prices.append(np.random.randint(start, end))

random = dict(zip(combinations2, random_prices))

print(get_revenue(results))
print(get_revenue(prices_season))
print(get_revenue(max))
print(get_revenue(min))
print(get_revenue(random))

a = get_revenue(results)
b = get_revenue(prices_season)
growth = (a-b)/b
growth

def get_weekly_revenue(x:list) -> list:
  S = RangeSet(0, 58)
  W = RangeSet(0, 23)
  P = RangeSet(0, 4)

  weekly_revenue = []
  for w in W:
     weekly_revenue.append([sum(x[w,p]*(sales_quantity[s,p]*(-(x[w,p]/prices_season[w,p])**2 - 0.075*x[w,p]/prices_season[w,p] + 2.85) /1.775
          + sum((prices_season[w,o]/x[w,o])**2 * relations[o,p] * sales_quantity[s,o] for o in P)) for s in S for p in P)])
  return weekly_revenue

y1 = get_weekly_revenue(results)
y2 = get_weekly_revenue(prices_season)
y3 = get_weekly_revenue(max)
y4 = get_weekly_revenue(min)
y5 = get_weekly_revenue(random)
x = range(24)

import matplotlib.pyplot as plt
plt.figure(figsize = (7, 5))

plt.plot(x,y1,'b',label='Выручка с оптимизацией')     # 'b' specifies blue
plt.plot(x,y2, 'r',label='Выручка без оптимизации')
plt.plot(x,y3, 'y',label='Максимальные цены')
plt.plot(x,y4, 'g',label='Минимальные цены')
plt.plot(x,y5, 'k',label='Случайные цены')

plt.title("Распределение выручки в зависимости от цен")
plt.xlabel("Недели")
plt.ylabel("Выручка")
plt.legend()

plt.show()
# -*- coding: utf-8 -*-
"""NextBestOffer_part2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dfzUAJjK8FPsBJgDE5GA0oEBdHsgyIPa

# библиотеки
"""

from google.colab import drive
drive.mount('/content/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/gdrive/My Drive/input data

import pandas as pd

# Commented out IPython magic to ensure Python compatibility.
# Установка pyomo и солвера cbc
# %pip install -q pyomo
!apt-get install -y -qq coinor-cbc

from pyomo.environ import *

"""# модель"""

df = pd.read_csv("frame_final.csv")
df = df.iloc[:,1:5]

df['product'] = df['product'].replace({'credit card':1,'credit':2})
df['channel'] = df['channel'].replace({'call':1, 'sms':2})

df = df.set_index(['client','product','channel']).sort_values(['client','product'])

nested_dict = df.to_dict(orient='index')

def get_optimization(df: pd.DataFrame, channel_limits: dict) -> list:
#создание модели
    model = ConcreteModel('nbo')

    model.C = RangeSet(0, 19999)  #clients
    model.P = RangeSet(1, 2) #products
    model.Ch = RangeSet(1, 2) #channels

#вектор бинарных переменных задачи
    model.x = Var(model.C, model.P, model.Ch, within=Binary)

#целевая функция
    objective_rule = sum(nested_dict[i,j,k]['proba'] * model.x[i,j,k] for i in model.C for j in model.P for k in model.Ch)
    model.obj = Objective(rule=objective_rule,sense=maximize)

#ограничения на количество коммуникаций в каждом канале
    model.c1 = Constraint(expr=sum(model.x[i,j,1] for i in model.C for j in model.P) <= 4000)
    model.c2 = Constraint(expr=sum(model.x[i,j,2] for i in model.C for j in model.P) <= 7000)

    model.constraintloop = ConstraintList()
    for i in model.C:
      model.constraintloop.add(expr=sum(model.x[i,j,k] for j in model.P for k in model.Ch) <= 1)
   #for k in model.Ch:
   #  model.constraintloop.add(expr=sum(model.x[i,j,k] for i in model.C for j in model.P) <= channel_limits[k])

# Инициализация солвера и решение задачи
    solver = SolverFactory('cbc', executable='/usr/bin/cbc')
    results = solver.solve(model, tee=True)

    results = []
    for i in model.C:
     for j in model.P:
       for k in model.Ch:
         results.append(value(model.x[i,j,k]))

    return results

#объем доступных коммуникаций в каналах
CHANNELS_LIMITS  = {
    1: 4000,
    2: 7000
}

optimal = get_optimization(df=df, channel_limits= CHANNELS_LIMITS)

df= df.reset_index(['client','channel', 'product'])

df['results'] = optimal
df['product'] = df['product'].replace({1:'credit card',2:'credit'})
df['channel'] = df['channel'].replace({1:'call', 2:'sms'})
df[df['results']==1].groupby(['channel', 'product']).agg({'client': 'count'})

subset_v = df[df['results']==1].groupby(['channel', 'product']).agg({'client': 'count'})
plot = subset_v.plot.pie(subplots=True,figsize=(4, 4))

#df.to_csv('pyomo_res.csv')

df['product'] = df['product'].replace({'credit card':1,'credit':2})
df['channel'] = df['channel'].replace({'call':1, 'sms':2})

df = df.set_index(['client','product','channel']).sort_values(['client','product'])

nested_dict = df.to_dict(orient='index')

def get_margin(df: pd.DataFrame, channel_limits: dict, margin: dict) -> list:
#создание модели
    model = ConcreteModel('nbo')

    model.C = RangeSet(0, 19999)  #clients
    model.P = RangeSet(1, 2) #products
    model.Ch = RangeSet(1, 2) #channels

#вектор бинарных переменных задачи
    model.x = Var(model.C, model.P, model.Ch, within=Binary)

#целевая функция
    objective_rule = sum(nested_dict[i,j,k]['proba'] * model.x[i,j,k]* margin[j,k] for i in model.C for j in model.P for k in model.Ch)
    model.obj = Objective(rule=objective_rule,sense=maximize)

#ограничения на количество коммуникаций в каждом канале
    model.c1 = Constraint(expr=sum(model.x[i,j,1] for i in model.C for j in model.P) <= 4000)
    model.c2 = Constraint(expr=sum(model.x[i,j,2] for i in model.C for j in model.P) <= 7000)

    model.constraintloop = ConstraintList()
    for i in model.C:
      model.constraintloop.add(expr=sum(model.x[i,j,k] for j in model.P for k in model.Ch) <= 1)
#for k in model.Ch:
#  model.constraintloop.add(expr=sum(model.x[i,j,k] for i in model.C for j in model.P) <= channel_limits[k])

# Инициализация солвера и решение задачи
    solver = SolverFactory('cbc', executable='/usr/bin/cbc')
    results = solver.solve(model, tee=True)

    results = []
    for i in model.C:
     for j in model.P:
       for k in model.Ch:
         results.append(value(model.x[i,j,k]))

    return results

#объем доступных коммуникаций в каналах
CHANNELS_LIMITS  = {
    1: 4000,
    2: 7000
}

MARGIN ={
    (1,1): 12950,
    (1,2): 12998.5,
    (2,1): 9950,
    (2,2): 9998.5
    }

optimals = get_margin(df=df, channel_limits=CHANNELS_LIMITS, margin=MARGIN)

df= df.reset_index(['client','channel', 'product'])

df['results_2'] = optimals
df['product'] = df['product'].replace({1:'credit card',2:'credit'})
df['channel'] = df['channel'].replace({1:'call', 2:'sms'})
df[df['results_2']==1].groupby(['channel', 'product']).agg({'client': 'count'})

"""## Анализ"""

import matplotlib.pyplot as plt

subset = df[df['results_2']==1].groupby(['channel', 'product']).agg({'client': 'count'})
plot = subset.plot.pie(subplots=True,figsize=(4, 4))

#df.to_csv('pyomo_results.csv')

df[(df['results']==1)&(df['results_2']== 1)].shape

df[(df['results']==1)&(df['results_2']== 0)].shape

def compute_grade(df):
    if df['product'] == 'credit card' and df['channel'] == 'call':
      return 12950
    elif df['product'] == 'credit card' and df['channel'] == 'sms':
      return 12998.5
    elif df['product'] == 'credit' and df['channel'] == 'call':
      return 9950
    elif df['product'] == 'credit' and df['channel'] == 'sms':
      return 9998.5

df['margin rate'] = df.apply(compute_grade, axis = 1)
df['margin'] = (df['proba'] * df['margin rate']).round(0)

df['calc'] =  df["channel"] + "-" + df["product"]

df[(df['results']==1)&(df['results_2']== 1)]['calc'].value_counts()

subset = df[(df['results']==1)&(df['results_2']== 1)]['calc'].value_counts(normalize=True)
plot = subset.plot.pie(subplots=True, figsize=(4, 4))

df[(df['results']==1)&(df['results_2']==0 )]['calc'].value_counts()

df[(df['results']==0)&(df['results_2']==1)]['calc'].value_counts()

#df[(df['results']==1)&(df['results_2']== 0)].groupby(['calc']).agg({'proba': 'median', 'margin rate': 'median','margin': 'median'})
df[(df['results']==1)&(df['results_2']== 0)].groupby(['calc']).agg({'proba': 'median'})

df[(df['results']==0)&(df['results_2']== 1)].groupby(['calc']).agg({'proba': 'median', 'margin rate': 'median','margin': 'median'})

df[(df['results_2']== 1)].groupby(['calc']).agg({'proba': 'mean', 'margin rate': 'mean','margin': 'sum'})

#df[(df['results']==1)&(df['results_2']== 0)].groupby(['calc']).agg({'proba': 'mean', 'margin rate': 'mean','margin': 'mean'})

"""#mip"""

pip install mip

import pandas as pd
from mip import Model, MAXIMIZE, CBC, BINARY, OptimizationStatus, xsum

column_labels = {'client': 'client_id',
               'product': 'product',
                'channel': 'channel',
                'proba': 'score'}

frame=df
frame.head(2)

frame = frame.rename(columns=column_labels)
frame

frame['product']= frame['product'].replace({1: 'credit card', 2: 'credit'})
frame['channel'] = frame['channel'].replace({1: 'call',2: 'sms'})

def optimize(frame: pd.DataFrame, channel_limits: dict) -> list:
    """
    Возвращает массив оптимальных предложений
    """
    df = frame.copy()

    #создание модели
    model = Model(sense=MAXIMIZE, solver_name=CBC)

    #вектор бинарных переменных задачи
    x = [model.add_var(var_type=BINARY) for i in range(df.shape[0])]
    df['x'] = x

    #целевая функция
    #функция xsum значительно ускоряет суммирование https://docs.python-mip.com/en/latest/classes.html#mip.xsum
    model.objective = xsum(df['score'] * df['x'])

    #ограничения на количество коммуникаций в каждом канале
    for channel in df.channel.unique():
        model += (xsum(df[df.channel==channel]['x']) <= channel_limits[channel])

    #ограничения на количество продуктов для каждого клиента (не более одного продукта на клиента)
    for product_cnt in df.groupby(['client_id'])['x'].apply(xsum):
        model += (product_cnt <= 1)

    status = model.optimize(max_seconds=300)

    del df

    if status == OptimizationStatus.OPTIMAL or status == OptimizationStatus.FEASIBLE:
        return [var.x for var in model.vars]
    elif status == OptimizationStatus.NO_SOLUTION_FOUND:
        print('No feasible solution found')

#объем доступных коммуникаций в каналах
CHANNELS_LIMITS = {
    'call': 4000,
    'sms': 7000
}

optimal_decisions = optimize(frame=frame, channel_limits=CHANNELS_LIMITS)
frame['optimal_decision'] = optimal_decisions

#распределение продуктов в каналах
frame[frame['optimal_decision']==1].groupby(['channel', 'product']).\
                                    agg({'client_id': 'count'}).\
                                    rename(columns={'client_id': 'client_cnt'})

"""# Материалы

https://or.stackexchange.com/questions/2582/pyomo-is-this-triple-summation-objective-function-formatted-correctly

https://colab.research.google.com/github/jckantor/cbe30338-book/blob/main/notebooks/05/05.99-Pyomo-Examples.ipynb

https://github.com/SolverMax/Collated/blob/main/Knapsack/A-pair-of-binary-knapsack-models/binary-knapsack.ipynb
"""